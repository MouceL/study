##### Pubsub

redis 的 list 可以实现简单的 队列，但是不支持多播，所以出现了一种新的模块 pubsub。

Pubsub 模块 完成了以下功能： 当多个消费者订阅了同一个topic 时候，只要生产者往该topic 中发送了一条消息，那么这些生产者都是可以接收的。但是它的消息是 推得方式，不像kafka那种消费者端控制offset。这就暴露了redis 作为多播的消息队列的劣势，当多个消费者中有消费者宕机，不在线时候，订阅的消息它是无法收到的。所以在实际生产过程中，这几乎没有什么实用场景。所以redis打算推出 disque 来专门做 多播，但是一直处于beta 版本。



##### 持久化

redis 的数据都是放在内存中的，如果机器宕机的话数据有丢失的危险。所以redis提供了两种持久化的方案,快照和aof.

~~~
快照方式，就是将内存中某一时刻是的数据都写进磁盘中，做一个全量的备份。那也许会问，redis是单线程的，它又要处理连接，又要把数据备份，这会不会降低redis的性能？ 
其实redis在全量备份前，会以fork出一个子进程，在fork出的那个时刻，子进程是和父进程共享内存的数据段代码段。然后fork出的子进程负责备份数据，而父进程用于处理连接。
当有修改数据的请求时，会从共享的页面中复制出来一段数据进行修改。 copy on write
这时子进程依旧备份的是旧的那份数据，它备份的是fork 那一时刻的数据，所以叫做快照。
~~~

~~~
而 AOF 则是将redis 实例运行以来所有的 redis 指令都存到 日志文件中，然后可以对这些日志文件中的指定重放而恢复redis的状态。
redis 先是验证指令的合法性，如果没问题就写到 AOF 中，然后再执行相关查询操作。
长期运行后，AOF日志会很大。 通过 bgrewwriteaof 指令对 日志进行 瘦身。原理就是开辟一个子进程对内存进行遍历，转换成一系列 redis 操作指令，序列化到一个新的 AOF 文件中，然后将该操作期间增量的 AOF 追加的新的 AOF 文件中。


AOF 文件先写入内存缓冲区，最后是写到 磁盘中的，所以如果宕机会导致 文件还没写到磁盘。 
linix 提供了 fsync 将制定文件内容强制从内核缓冲区刷到磁盘。只要 redis 实时调用 fsync 就保证不丢数据
通常1s 调用一次。
~~~

一般主节点对外提供服务，不会进行持久化操作，持久化主要用在从节点。

redis 4.0 提供了混合方式，

~~~
redis 在重启的时候不会用 rdb 恢复内存状态，因为会丢失大量数据。通常使用 AOF 方式，但是速度比较慢。
为了解决这个问题，redis 4.0 提供了混合方式，rdb + aof ,其中aof 是持久化开始到持久化结束的增量aof.
在重启的时候，先加载rdb ,在 + aof
~~~




##### 管道

管道是一个 客户端的技术，现在说下一个客户端请求的过程

~~~
1. 客户端将指令写入内核发送缓存区
2. 将发送缓冲区的内容刷到网卡
3. 网卡将数据发送的redis 服务端网卡
4. 往网卡的数据复制到服务器接收缓冲区
5. 服务器调用 read 从接收缓冲区取数据
6. 查询
7. 将结果写入发送缓冲区
8. 将发送缓冲区的内容刷到网卡并发送到客户端网卡，放到内核接收缓冲区
9. 客户端调用 read
~~~

所以写操作是将数据写入内核缓冲区，不用等待，而读操作是要等内核接收缓冲区有数据才能读。

~~~
write-> read->write->read 可以在客户端 调整为
write -> write -> read -> read 
~~~

简单的调整顺序就能极大的提供查询性能。

